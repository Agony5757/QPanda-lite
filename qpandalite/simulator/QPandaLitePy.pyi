"""
[Module QPandaLitePy]
"""
from __future__ import annotations
import typing
__all__ = ['BitFlip', 'CNOT', 'CSWAP', 'CZ', 'Damping', 'DensityOperatorSimulator', 'Depolarizing', 'HADAMARD', 'IDENTITY', 'ISWAP', 'NoiseType', 'NoisySimulator', 'NoisySimulator_GateDependent', 'NoisySimulator_GateSpecificError', 'OpcodeType', 'PhaseFlip', 'RPHI', 'RPHI180', 'RPHI90', 'RX', 'RY', 'RZ', 'S', 'SX', 'StatevectorSimulator', 'T', 'TOFFOLI', 'TwoQubitDepolarizing', 'U22', 'UnitaryType', 'X', 'XY', 'Y', 'Z', 'rand', 'seed']
class DensityOperatorSimulator:
    max_qubit_num: typing.ClassVar[int] = 10
    def __init__(self) -> None:
        ...
    def cnot(self, controller: int, target: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def cswap(self, controller: int, target1: int, target2: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def cz(self, qn1: int, qn2: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    @typing.overload
    def get_prob(self, arg0: int, arg1: int) -> float:
        ...
    @typing.overload
    def get_prob(self, arg0: dict[int, int]) -> float:
        ...
    def hadamard(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def init_n_qubit(self, arg0: int) -> None:
        ...
    def iswap(self, qn1: int, qn2: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def phase2q(self, qn1: int, qn2: int, theta1: float, theta2: float, thetazz: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    @typing.overload
    def pmeasure(self, arg0: int) -> list[float]:
        ...
    @typing.overload
    def pmeasure(self, arg0: list[int]) -> list[float]:
        ...
    def rphi(self, qn: int, theta: float, phi: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def rphi180(self, qn: int, phi: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def rphi90(self, qn: int, phi: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def rx(self, qn: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def ry(self, qn: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def rz(self, qn: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def s(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def stateprob(self) -> list[float]:
        ...
    def swap(self, qn1: int, qn2: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def sx(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def t(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def toffoli(self, controller1: int, controller2: int, target: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def u1(self, qn: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def u2(self, qn: int, phi: float, lamda: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def u22(self, qn: int, unitary: list[complex[4]], global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def u3(self, qn: int, theta: float, phi: float, lamda: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def uu15(self, qn1: int, qn2: int, parameters: list[float], global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def x(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def xx(self, qn1: int, qn2: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def xy(self, qn1: int, qn2: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def y(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def yy(self, qn1: int, qn2: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def z(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def zz(self, qn1: int, qn2: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    @property
    def state(self) -> list[complex]:
        ...
    @property
    def total_qubit(self) -> int:
        ...
class NoiseType:
    """
    Members:
    
      Depolarizing
    
      Damping
    
      BitFlip
    
      PhaseFlip
    
      TwoQubitDepolarizing
    """
    BitFlip: typing.ClassVar[NoiseType]  # value = <NoiseType.BitFlip: 20003>
    Damping: typing.ClassVar[NoiseType]  # value = <NoiseType.Damping: 20002>
    Depolarizing: typing.ClassVar[NoiseType]  # value = <NoiseType.Depolarizing: 20001>
    PhaseFlip: typing.ClassVar[NoiseType]  # value = <NoiseType.PhaseFlip: 20004>
    TwoQubitDepolarizing: typing.ClassVar[NoiseType]  # value = <NoiseType.TwoQubitDepolarizing: 20005>
    __members__: typing.ClassVar[dict[str, NoiseType]]  # value = {'Depolarizing': <NoiseType.Depolarizing: 20001>, 'Damping': <NoiseType.Damping: 20002>, 'BitFlip': <NoiseType.BitFlip: 20003>, 'PhaseFlip': <NoiseType.PhaseFlip: 20004>, 'TwoQubitDepolarizing': <NoiseType.TwoQubitDepolarizing: 20005>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class NoisySimulator:
    def __init__(self, n_qubit: int, noise_description: dict[str, float] = {}, measurement_error: list[list[float[2]]] = []) -> None:
        ...
    def cnot(self, controller: int, target: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def cz(self, qn1: int, qn2: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def get_measure(self) -> int:
        ...
    def get_measure_no_readout_error(self) -> int:
        ...
    def hadamard(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def insert_error(self, arg0: list[int], arg1: UnitaryType) -> None:
        ...
    def iswap(self, qn1: int, qn2: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def load_opcode(self, arg0: str, arg1: list[int], arg2: list[float], arg3: bool, arg4: list[int]) -> None:
        ...
    @typing.overload
    def measure_shots(self, measure_qubits: list[int], shots: int) -> dict[int, int]:
        ...
    @typing.overload
    def measure_shots(self, shots: int) -> dict[int, int]:
        ...
    def rphi(self, qn: int, phi: float, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def rphi180(self, qn: int, phi: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def rphi90(self, qn: int, phi: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def rx(self, qn: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def ry(self, qn: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def rz(self, qn: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def sx(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def u22(self, qn: int, unitary: list[complex[4]], global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def x(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def xy(self, qn1: int, qn2: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def y(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def z(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    @property
    def measurement_error_matrices(self) -> list[list[float[2]]]:
        ...
    @property
    def noise(self) -> dict[NoiseType, float]:
        ...
    @property
    def total_qubit(self) -> int:
        ...
class NoisySimulator_GateDependent(NoisySimulator):
    def __init__(self, n_qubit: int, noise_description: dict[str, float] = {}, gate_noise_description: dict[str, dict[str, float]] = {}, measurement_error: list[list[float[2]]] = []) -> None:
        ...
class NoisySimulator_GateSpecificError(NoisySimulator):
    def __init__(self, n_qubit: int, noise_description: dict[str, float] = {}, gate_error1q_description: dict[tuple[str, int], dict[str, float]] = {}, gate_error2q_description: dict[tuple[str, tuple[int, int]], dict[str, float]] = {}, measurement_error: list[list[float[2]]] = []) -> None:
        ...
class OpcodeType:
    op: int
    def __init__(self, arg0: int, arg1: list[int], arg2: list[float], arg3: bool, arg4: list[int]) -> None:
        ...
class StatevectorSimulator:
    max_qubit_num: typing.ClassVar[int] = 30
    def __init__(self) -> None:
        ...
    def amplitude_damping(self, qn: int, gamma: float) -> None:
        ...
    def bitflip(self, qn: int, p: float) -> None:
        ...
    def cnot(self, controller: int, target: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def cswap(self, controller: int, target1: int, target2: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def cz(self, qn1: int, qn2: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def depolarizing(self, qn: int, p: float) -> None:
        ...
    @typing.overload
    def get_prob(self, qn: int, qstate: int) -> float:
        ...
    @typing.overload
    def get_prob(self, measure_map: dict[int, int]) -> float:
        ...
    def hadamard(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def init_n_qubit(self, arg0: int) -> None:
        ...
    def iswap(self, qn1: int, qn2: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def kraus1q(self, qn: int, kraus_ops: list[list[complex[4]]]) -> None:
        ...
    @typing.overload
    def measure_single_shot(self, qubit: int) -> int:
        ...
    @typing.overload
    def measure_single_shot(self, qubits: list[int]) -> int:
        ...
    def pauli_error_1q(self, qn: int, px: float, py: float, pz: float) -> None:
        ...
    def pauli_error_2q(self, qn1: int, qn2: int, p: list[float]) -> None:
        ...
    def phase2q(self, qn1: int, qn2: int, theta1: float, theta2: float, thetazz: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def phaseflip(self, qn: int, p: float) -> None:
        ...
    @typing.overload
    def pmeasure(self, qn: int) -> list[float]:
        ...
    @typing.overload
    def pmeasure(self, measure_qubits: list[int]) -> list[float]:
        ...
    def rphi(self, qn: int, theta: float, phi: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def rphi180(self, qn: int, phi: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def rphi90(self, qn: int, phi: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def rx(self, qn: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def ry(self, qn: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def rz(self, qn: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def s(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def swap(self, qn1: int, qn2: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def sx(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def t(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def toffoli(self, controller1: int, controller2: int, target: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def twoqubit_depolarizing(self, qn1: int, qn2: int, p: float) -> None:
        ...
    def u1(self, qn: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def u2(self, qn: int, phi: float, lamda: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def u22(self, qn: int, unitary: list[complex[4]], global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def u3(self, qn: int, theta: float, phi: float, lamda: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def uu15(self, qn1: int, qn2: int, parameters: list[float], global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def x(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def xx(self, qn1: int, qn2: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def xy(self, qn1: int, qn2: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def y(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def yy(self, qn1: int, qn2: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def z(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def zz(self, qn1: int, qn2: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    @property
    def state(self) -> list[complex]:
        ...
    @property
    def total_qubit(self) -> int:
        ...
class UnitaryType:
    """
    Members:
    
      HADAMARD
    
      IDENTITY
    
      U22
    
      X
    
      Y
    
      Z
    
      S
    
      T
    
      SX
    
      CZ
    
      ISWAP
    
      XY
    
      CNOT
    
      RX
    
      RY
    
      RZ
    
      RPHI90
    
      RPHI180
    
      RPHI
    
      TOFFOLI
    
      CSWAP
    """
    CNOT: typing.ClassVar[UnitaryType]  # value = <UnitaryType.CNOT: 1014>
    CSWAP: typing.ClassVar[UnitaryType]  # value = <UnitaryType.CSWAP: 1024>
    CZ: typing.ClassVar[UnitaryType]  # value = <UnitaryType.CZ: 1010>
    HADAMARD: typing.ClassVar[UnitaryType]  # value = <UnitaryType.HADAMARD: 1002>
    IDENTITY: typing.ClassVar[UnitaryType]  # value = <UnitaryType.IDENTITY: 1001>
    ISWAP: typing.ClassVar[UnitaryType]  # value = <UnitaryType.ISWAP: 1012>
    RPHI: typing.ClassVar[UnitaryType]  # value = <UnitaryType.RPHI: 1022>
    RPHI180: typing.ClassVar[UnitaryType]  # value = <UnitaryType.RPHI180: 1021>
    RPHI90: typing.ClassVar[UnitaryType]  # value = <UnitaryType.RPHI90: 1020>
    RX: typing.ClassVar[UnitaryType]  # value = <UnitaryType.RX: 1015>
    RY: typing.ClassVar[UnitaryType]  # value = <UnitaryType.RY: 1016>
    RZ: typing.ClassVar[UnitaryType]  # value = <UnitaryType.RZ: 1017>
    S: typing.ClassVar[UnitaryType]  # value = <UnitaryType.S: 1007>
    SX: typing.ClassVar[UnitaryType]  # value = <UnitaryType.SX: 1009>
    T: typing.ClassVar[UnitaryType]  # value = <UnitaryType.T: 1008>
    TOFFOLI: typing.ClassVar[UnitaryType]  # value = <UnitaryType.TOFFOLI: 1023>
    U22: typing.ClassVar[UnitaryType]  # value = <UnitaryType.U22: 1003>
    X: typing.ClassVar[UnitaryType]  # value = <UnitaryType.X: 1004>
    XY: typing.ClassVar[UnitaryType]  # value = <UnitaryType.XY: 1013>
    Y: typing.ClassVar[UnitaryType]  # value = <UnitaryType.Y: 1005>
    Z: typing.ClassVar[UnitaryType]  # value = <UnitaryType.Z: 1006>
    __members__: typing.ClassVar[dict[str, UnitaryType]]  # value = {'HADAMARD': <UnitaryType.HADAMARD: 1002>, 'IDENTITY': <UnitaryType.IDENTITY: 1001>, 'U22': <UnitaryType.U22: 1003>, 'X': <UnitaryType.X: 1004>, 'Y': <UnitaryType.Y: 1005>, 'Z': <UnitaryType.Z: 1006>, 'S': <UnitaryType.S: 1007>, 'T': <UnitaryType.T: 1008>, 'SX': <UnitaryType.SX: 1009>, 'CZ': <UnitaryType.CZ: 1010>, 'ISWAP': <UnitaryType.ISWAP: 1012>, 'XY': <UnitaryType.XY: 1013>, 'CNOT': <UnitaryType.CNOT: 1014>, 'RX': <UnitaryType.RX: 1015>, 'RY': <UnitaryType.RY: 1016>, 'RZ': <UnitaryType.RZ: 1017>, 'RPHI90': <UnitaryType.RPHI90: 1020>, 'RPHI180': <UnitaryType.RPHI180: 1021>, 'RPHI': <UnitaryType.RPHI: 1022>, 'TOFFOLI': <UnitaryType.TOFFOLI: 1023>, 'CSWAP': <UnitaryType.CSWAP: 1024>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
def rand() -> float:
    ...
def seed(arg0: int) -> None:
    ...
BitFlip: NoiseType  # value = <NoiseType.BitFlip: 20003>
CNOT: UnitaryType  # value = <UnitaryType.CNOT: 1014>
CSWAP: UnitaryType  # value = <UnitaryType.CSWAP: 1024>
CZ: UnitaryType  # value = <UnitaryType.CZ: 1010>
Damping: NoiseType  # value = <NoiseType.Damping: 20002>
Depolarizing: NoiseType  # value = <NoiseType.Depolarizing: 20001>
HADAMARD: UnitaryType  # value = <UnitaryType.HADAMARD: 1002>
IDENTITY: UnitaryType  # value = <UnitaryType.IDENTITY: 1001>
ISWAP: UnitaryType  # value = <UnitaryType.ISWAP: 1012>
PhaseFlip: NoiseType  # value = <NoiseType.PhaseFlip: 20004>
RPHI: UnitaryType  # value = <UnitaryType.RPHI: 1022>
RPHI180: UnitaryType  # value = <UnitaryType.RPHI180: 1021>
RPHI90: UnitaryType  # value = <UnitaryType.RPHI90: 1020>
RX: UnitaryType  # value = <UnitaryType.RX: 1015>
RY: UnitaryType  # value = <UnitaryType.RY: 1016>
RZ: UnitaryType  # value = <UnitaryType.RZ: 1017>
S: UnitaryType  # value = <UnitaryType.S: 1007>
SX: UnitaryType  # value = <UnitaryType.SX: 1009>
T: UnitaryType  # value = <UnitaryType.T: 1008>
TOFFOLI: UnitaryType  # value = <UnitaryType.TOFFOLI: 1023>
TwoQubitDepolarizing: NoiseType  # value = <NoiseType.TwoQubitDepolarizing: 20005>
U22: UnitaryType  # value = <UnitaryType.U22: 1003>
X: UnitaryType  # value = <UnitaryType.X: 1004>
XY: UnitaryType  # value = <UnitaryType.XY: 1013>
Y: UnitaryType  # value = <UnitaryType.Y: 1005>
Z: UnitaryType  # value = <UnitaryType.Z: 1006>
