"""
[Module QPandaLitePy]
"""
from __future__ import annotations
import typing
__all__ = ['BitFlip', 'CNOT', 'CSWAP', 'CZ', 'Damping', 'DensityOperatorSimulator', 'Depolarizing', 'HADAMARD', 'IDENTITY', 'ISWAP', 'NoiseType', 'NoisySimulator', 'NoisySimulator_GateDependent', 'NoisySimulator_GateSpecificError', 'OpcodeType', 'PhaseFlip', 'RPHI', 'RPHI180', 'RPHI90', 'RX', 'RY', 'RZ', 'S', 'SX', 'StatevectorSimulator', 'SupportOperationType', 'T', 'TOFFOLI', 'TwoQubitDepolarizing', 'U22', 'X', 'XY', 'Y', 'Z', 'rand', 'seed']
class DensityOperatorSimulator:
    max_qubit_num: typing.ClassVar[int] = 10
    def __init__(self) -> None:
        ...
    def cnot(self, controller: int, target: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def cswap(self, controller: int, target1: int, target2: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def cz(self, qn1: int, qn2: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    @typing.overload
    def get_prob(self, arg0: int, arg1: int) -> float:
        ...
    @typing.overload
    def get_prob(self, arg0: dict[int, int]) -> float:
        ...
    def hadamard(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def init_n_qubit(self, arg0: int) -> None:
        ...
    def iswap(self, qn1: int, qn2: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def phase2q(self, qn1: int, qn2: int, theta1: float, theta2: float, thetazz: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    @typing.overload
    def pmeasure(self, arg0: int) -> list[float]:
        ...
    @typing.overload
    def pmeasure(self, arg0: list[int]) -> list[float]:
        ...
    def rphi(self, qn: int, theta: float, phi: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def rphi180(self, qn: int, phi: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def rphi90(self, qn: int, phi: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def rx(self, qn: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def ry(self, qn: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def rz(self, qn: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def s(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def stateprob(self) -> list[float]:
        ...
    def swap(self, qn1: int, qn2: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def sx(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def t(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def toffoli(self, controller1: int, controller2: int, target: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def u1(self, qn: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def u2(self, qn: int, phi: float, lamda: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def u22(self, qn: int, unitary: list[complex[4]], global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def u3(self, qn: int, theta: float, phi: float, lamda: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def uu15(self, qn1: int, qn2: int, parameters: list[float], global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def x(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def xx(self, qn1: int, qn2: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def xy(self, qn1: int, qn2: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def y(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def yy(self, qn1: int, qn2: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def z(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def zz(self, qn1: int, qn2: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    @property
    def state(self) -> list[complex]:
        ...
    @property
    def total_qubit(self) -> int:
        ...
class NoiseType:
    """
    Members:
    
      Depolarizing
    
      Damping
    
      BitFlip
    
      PhaseFlip
    
      TwoQubitDepolarizing
    """
    BitFlip: typing.ClassVar[NoiseType]  # value = <NoiseType.BitFlip: 3>
    Damping: typing.ClassVar[NoiseType]  # value = <NoiseType.Damping: 2>
    Depolarizing: typing.ClassVar[NoiseType]  # value = <NoiseType.Depolarizing: 1>
    PhaseFlip: typing.ClassVar[NoiseType]  # value = <NoiseType.PhaseFlip: 4>
    TwoQubitDepolarizing: typing.ClassVar[NoiseType]  # value = <NoiseType.TwoQubitDepolarizing: 5>
    __members__: typing.ClassVar[dict[str, NoiseType]]  # value = {'Depolarizing': <NoiseType.Depolarizing: 1>, 'Damping': <NoiseType.Damping: 2>, 'BitFlip': <NoiseType.BitFlip: 3>, 'PhaseFlip': <NoiseType.PhaseFlip: 4>, 'TwoQubitDepolarizing': <NoiseType.TwoQubitDepolarizing: 5>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class NoisySimulator:
    def __init__(self, n_qubit: int, noise_description: dict[str, float] = {}, measurement_error: list[list[float[2]]] = []) -> None:
        ...
    def cnot(self, controller: int, target: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def cz(self, qn1: int, qn2: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def get_measure(self) -> int:
        ...
    def get_measure_no_readout_error(self) -> int:
        ...
    def hadamard(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def insert_error(self, arg0: list[int], arg1: SupportOperationType) -> None:
        ...
    def iswap(self, qn1: int, qn2: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def load_opcode(self, arg0: str, arg1: list[int], arg2: list[float], arg3: bool, arg4: list[int]) -> None:
        ...
    @typing.overload
    def measure_shots(self, measure_qubits: list[int], shots: int) -> dict[int, int]:
        ...
    @typing.overload
    def measure_shots(self, shots: int) -> dict[int, int]:
        ...
    def rphi(self, qn: int, phi: float, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def rphi180(self, qn: int, phi: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def rphi90(self, qn: int, phi: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def rx(self, qn: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def ry(self, qn: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def rz(self, qn: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def sx(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def u22(self, qn: int, unitary: list[complex[4]], global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def x(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def xy(self, qn1: int, qn2: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def y(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def z(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    @property
    def measurement_error_matrices(self) -> list[list[float[2]]]:
        ...
    @property
    def noise(self) -> dict[NoiseType, float]:
        ...
    @property
    def total_qubit(self) -> int:
        ...
class NoisySimulator_GateDependent(NoisySimulator):
    def __init__(self, n_qubit: int, noise_description: dict[str, float] = {}, gate_noise_description: dict[str, dict[str, float]] = {}, measurement_error: list[list[float[2]]] = []) -> None:
        ...
class NoisySimulator_GateSpecificError(NoisySimulator):
    def __init__(self, n_qubit: int, noise_description: dict[str, float] = {}, gate_error1q_description: dict[tuple[str, int], dict[str, float]] = {}, gate_error2q_description: dict[tuple[str, tuple[int, int]], dict[str, float]] = {}, measurement_error: list[list[float[2]]] = []) -> None:
        ...
class OpcodeType:
    op: int
    def __init__(self, arg0: int, arg1: list[int], arg2: list[float], arg3: bool, arg4: list[int]) -> None:
        ...
class StatevectorSimulator:
    max_qubit_num: typing.ClassVar[int] = 30
    def __init__(self) -> None:
        ...
    def cnot(self, controller: int, target: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def cswap(self, controller: int, target1: int, target2: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def cz(self, qn1: int, qn2: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    @typing.overload
    def get_prob(self, arg0: int, arg1: int) -> float:
        ...
    @typing.overload
    def get_prob(self, arg0: dict[int, int]) -> float:
        ...
    def hadamard(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def init_n_qubit(self, arg0: int) -> None:
        ...
    def iswap(self, qn1: int, qn2: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def phase2q(self, qn1: int, qn2: int, theta1: float, theta2: float, thetazz: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    @typing.overload
    def pmeasure(self, arg0: int) -> list[float]:
        ...
    @typing.overload
    def pmeasure(self, arg0: list[int]) -> list[float]:
        ...
    def rphi(self, qn: int, theta: float, phi: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def rphi180(self, qn: int, phi: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def rphi90(self, qn: int, phi: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def rx(self, qn: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def ry(self, qn: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def rz(self, qn: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def s(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def swap(self, qn1: int, qn2: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def sx(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def t(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def toffoli(self, controller1: int, controller2: int, target: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def u1(self, qn: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def u2(self, qn: int, phi: float, lamda: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def u22(self, qn: int, unitary: list[complex[4]], global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def u3(self, qn: int, theta: float, phi: float, lamda: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def uu15(self, qn1: int, qn2: int, parameters: list[float], global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def x(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def xx(self, qn1: int, qn2: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def xy(self, qn1: int, qn2: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def y(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def yy(self, qn1: int, qn2: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def z(self, qn: int, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    def zz(self, qn1: int, qn2: int, theta: float, global_controller: list[int] = [], dagger: bool = False) -> None:
        ...
    @property
    def state(self) -> list[complex]:
        ...
    @property
    def total_qubit(self) -> int:
        ...
class SupportOperationType:
    """
    Members:
    
      HADAMARD
    
      IDENTITY
    
      U22
    
      X
    
      Y
    
      Z
    
      S
    
      T
    
      SX
    
      CZ
    
      ISWAP
    
      XY
    
      CNOT
    
      RX
    
      RY
    
      RZ
    
      RPHI90
    
      RPHI180
    
      RPHI
    
      TOFFOLI
    
      CSWAP
    """
    CNOT: typing.ClassVar[SupportOperationType]  # value = <SupportOperationType.CNOT: 1014>
    CSWAP: typing.ClassVar[SupportOperationType]  # value = <SupportOperationType.CSWAP: 1022>
    CZ: typing.ClassVar[SupportOperationType]  # value = <SupportOperationType.CZ: 1010>
    HADAMARD: typing.ClassVar[SupportOperationType]  # value = <SupportOperationType.HADAMARD: 1001>
    IDENTITY: typing.ClassVar[SupportOperationType]  # value = <SupportOperationType.IDENTITY: 1002>
    ISWAP: typing.ClassVar[SupportOperationType]  # value = <SupportOperationType.ISWAP: 1012>
    RPHI: typing.ClassVar[SupportOperationType]  # value = <SupportOperationType.RPHI: 1020>
    RPHI180: typing.ClassVar[SupportOperationType]  # value = <SupportOperationType.RPHI180: 1019>
    RPHI90: typing.ClassVar[SupportOperationType]  # value = <SupportOperationType.RPHI90: 1018>
    RX: typing.ClassVar[SupportOperationType]  # value = <SupportOperationType.RX: 1015>
    RY: typing.ClassVar[SupportOperationType]  # value = <SupportOperationType.RY: 1016>
    RZ: typing.ClassVar[SupportOperationType]  # value = <SupportOperationType.RZ: 1017>
    S: typing.ClassVar[SupportOperationType]  # value = <SupportOperationType.S: 1007>
    SX: typing.ClassVar[SupportOperationType]  # value = <SupportOperationType.SX: 1009>
    T: typing.ClassVar[SupportOperationType]  # value = <SupportOperationType.T: 1008>
    TOFFOLI: typing.ClassVar[SupportOperationType]  # value = <SupportOperationType.TOFFOLI: 1021>
    U22: typing.ClassVar[SupportOperationType]  # value = <SupportOperationType.U22: 1003>
    X: typing.ClassVar[SupportOperationType]  # value = <SupportOperationType.X: 1004>
    XY: typing.ClassVar[SupportOperationType]  # value = <SupportOperationType.XY: 1013>
    Y: typing.ClassVar[SupportOperationType]  # value = <SupportOperationType.Y: 1005>
    Z: typing.ClassVar[SupportOperationType]  # value = <SupportOperationType.Z: 1006>
    __members__: typing.ClassVar[dict[str, SupportOperationType]]  # value = {'HADAMARD': <SupportOperationType.HADAMARD: 1001>, 'IDENTITY': <SupportOperationType.IDENTITY: 1002>, 'U22': <SupportOperationType.U22: 1003>, 'X': <SupportOperationType.X: 1004>, 'Y': <SupportOperationType.Y: 1005>, 'Z': <SupportOperationType.Z: 1006>, 'S': <SupportOperationType.S: 1007>, 'T': <SupportOperationType.T: 1008>, 'SX': <SupportOperationType.SX: 1009>, 'CZ': <SupportOperationType.CZ: 1010>, 'ISWAP': <SupportOperationType.ISWAP: 1012>, 'XY': <SupportOperationType.XY: 1013>, 'CNOT': <SupportOperationType.CNOT: 1014>, 'RX': <SupportOperationType.RX: 1015>, 'RY': <SupportOperationType.RY: 1016>, 'RZ': <SupportOperationType.RZ: 1017>, 'RPHI90': <SupportOperationType.RPHI90: 1018>, 'RPHI180': <SupportOperationType.RPHI180: 1019>, 'RPHI': <SupportOperationType.RPHI: 1020>, 'TOFFOLI': <SupportOperationType.TOFFOLI: 1021>, 'CSWAP': <SupportOperationType.CSWAP: 1022>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
def rand() -> float:
    ...
def seed(arg0: int) -> None:
    ...
BitFlip: NoiseType  # value = <NoiseType.BitFlip: 3>
CNOT: SupportOperationType  # value = <SupportOperationType.CNOT: 1014>
CSWAP: SupportOperationType  # value = <SupportOperationType.CSWAP: 1022>
CZ: SupportOperationType  # value = <SupportOperationType.CZ: 1010>
Damping: NoiseType  # value = <NoiseType.Damping: 2>
Depolarizing: NoiseType  # value = <NoiseType.Depolarizing: 1>
HADAMARD: SupportOperationType  # value = <SupportOperationType.HADAMARD: 1001>
IDENTITY: SupportOperationType  # value = <SupportOperationType.IDENTITY: 1002>
ISWAP: SupportOperationType  # value = <SupportOperationType.ISWAP: 1012>
PhaseFlip: NoiseType  # value = <NoiseType.PhaseFlip: 4>
RPHI: SupportOperationType  # value = <SupportOperationType.RPHI: 1020>
RPHI180: SupportOperationType  # value = <SupportOperationType.RPHI180: 1019>
RPHI90: SupportOperationType  # value = <SupportOperationType.RPHI90: 1018>
RX: SupportOperationType  # value = <SupportOperationType.RX: 1015>
RY: SupportOperationType  # value = <SupportOperationType.RY: 1016>
RZ: SupportOperationType  # value = <SupportOperationType.RZ: 1017>
S: SupportOperationType  # value = <SupportOperationType.S: 1007>
SX: SupportOperationType  # value = <SupportOperationType.SX: 1009>
T: SupportOperationType  # value = <SupportOperationType.T: 1008>
TOFFOLI: SupportOperationType  # value = <SupportOperationType.TOFFOLI: 1021>
TwoQubitDepolarizing: NoiseType  # value = <NoiseType.TwoQubitDepolarizing: 5>
U22: SupportOperationType  # value = <SupportOperationType.U22: 1003>
X: SupportOperationType  # value = <SupportOperationType.X: 1004>
XY: SupportOperationType  # value = <SupportOperationType.XY: 1013>
Y: SupportOperationType  # value = <SupportOperationType.Y: 1005>
Z: SupportOperationType  # value = <SupportOperationType.Z: 1006>
